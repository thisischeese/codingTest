import sys 

MOD = 1_000_000_007
input = sys.stdin.readline 


N = int(input())
arr = list(map(int,input().split()))
arr.sort() 

answer = 0 

for i in range(N):
    coef = (pow(2,i,MOD)-pow(2,N-1-i,MOD)+MOD)%MOD
    answer = (answer+arr[i]*coef)%MOD
  
print(answer)

'''
스코빌 지수가 있을 때 그 최댓값과 최솟값의 차이를 "주헌고통지수"라고 정의한다.
하지만 주헌이는 까다로워서 한 번 먹어본 조합은 다시 먹지 않는다. -> 순열 x 조합 o 
이 음식점의 모든 조합을 먹어 볼 때 주헌이가 즐길 수 있는 주헌고통지수의 합을 구해보자. -> 모든 조합별(max-min) 합
1 ≤ N ≤ 300,000 3*10^5 

5,2 -> 3
5,8 -> 3
2,8 -> 6
2,5,8 -> 6

=> 모든 조합을 굳이 만들어야 할까?
=> 최대 최소가 될 수 있는 원소만 알면 되지 않을까? 
=> 즉 전체 원소들 중 유일한 2개 묶음을 구하고 차이만 알면 된다? 
=> 오름차순 나열해서 최소, 최대 안에 들어갈 수 있는 원소 조합 개수만 알고 차이에 곱하면 될 듯 

=> 수학적 아이디어 : 이항계수 연속적 합 (1+1)^k 와 같음 
    => 시간초과 
    => min max를 이중 for문으로 한 번에 계산해야 할 필요가 잇을지? 수학적으로 항 분리 가능함 
=> SUM(arr[i]*(2^i-2^(N-1-i)))
'''